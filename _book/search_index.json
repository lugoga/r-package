[["index.html", "Bundle your codes in Package R package development, writing good documentation and vignettes Welcome Note Colophon License", " Bundle your codes in Package R package development, writing good documentation and vignettes Masumbuko Semba Nyamisi Peter Ismael Kimirei 2020-11-13 Welcome Note This book highlight some basic steps one need to know to start building R packages (R Core Team 2020). It also describe techniques for writing good code for data science. The main author of this book, Masumbuko Semba semba-blog.netlify.com developed this version of the book while doing his doctoral study at the Institute of Marine Sciences of the University of Dar es Salaam, Zanzibar. His prime aim was to help scientist in marine and freshwater systems have a glimpse of visualizing and exploring data in modern ways like using web apps. Several other contributors were instrumental in the development of materials in this book. Some of contributors include Ismael Kimirei, Yohanna Shaghude, Nyamisi Peter, Baraka Kuguru, Ntahondo Nyandwi, Patroba Matiku, Mathew Silas Colophon This book was written in bookdown(Xie 2020) inside RStudio. The website semba-blog is hosted with Netlify, and automatically updated after every commit by Travis-CI. The complete source is available from GitHub. The logo and the book style was designed by Masumbuko Semba. License This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. This is a human-readable summary of (and not a substitute for) the license. Please see https://creativecommons.org/licenses/by-sa/4.0/legalcode for the full legal text. You are free to: Sharecopy and redistribute the material in any medium or format Remixremix, transform, and build upon the material for any purpose, even commercially. The licensor cannot revoke these freedoms as long as you follow the license terms. Under the following terms: AttributionYou must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. ShareAlikeIf you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. No additional restrictionsYou may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. Notices: You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation. No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material. Citation For attribution, please cite this work as Semba M (2020). Developing packages in R. Retrieve from &quot;https://lugoga.github.io/babye/&quot; BibTex format @misc{semba2020p, author = {Masumbuko, Semba}, title = {babye: a package to access and dowload satellite data}, ur = {https://lugoga.github.io/babye/}, year = {2020} } References "],["introduction.html", "Chapter 1 Introduction 1.1 Basic Structure of an R Package", " Chapter 1 Introduction An R package is a mechanism for extending the basic functionality of R. It is the natural extension of writing functions that each do a specific thing well. When we interact with R, we use functions from either packages or R-base(R Core Team 2020). The use of functions simplifies things for the user because the user no longer needs to be knowledgeable of the details of the underlying code. They only need to understand the inputs and outputs. Once one has developed many functions, it becomes natural to group them in to collections of functions that are aimed at achieving an overall goal. This collection of functions can be assembled into an R package. R packages represent another level of abstraction, where the interface presented to the user is a set of user-facing functions. These functions provide access to the underlying functionality of the package and simplify the user experience because the one does not need to be concerned with the many other helper functions that are required. R packages are a much better way to distribute code to others because they provide a clean and uniform user experience for people who want to interact with your code. R packages require documentation in a standardized format, and the various tools that come with R (and RStudio) help to check your packages so that they do not contain inconsistencies or errors. R users are already familiar with how to use R packages, and so they will be able to quickly adopt your code if is presented in this format. This chapter highlights the key elements of building R packages. The fine details of building a package can be found in the Writing R Extensions manual. The objectives of this section are: Recognize the basic structure and purpose of an R package Recognize the key directives in a NAMESPACE file 1.1 Basic Structure of an R Package An R package begins life as a directory on your computer. This directory has a specific layout with specific files and sub-directories. The two required sub-directories are R, which contains all of your R code files man, which contains your documentation files. At the top level of your package directory you will have a DESCRIPTION file and a NAMESPACE file. This represents the minimal requirements for an R package. Other files and sub-directories can be added and will discuss how and why in the sections below. While RStudio is not required to build R packages, it contains a number of convenient features that make the development process easier and faster. That said, in order to use RStudio for package development, you must setup the environment properly. Details of how to do this can be found in Rogers RStudio package development pre-flight check list. 1.1.1 DESCRIPTION File The DESCRIPTION file is an essential part of an R package because it contains key metadata for the package that is used by repositories like CRAN and by R itself. In particular, this file contains the package name, the version number, the author and maintainer contact information, the license information, as well as any dependencies on other packages. As an example, here is the DESCRIPTION file for the wior package (Semba and Peter 2020). This package provides a function for accessing and downloading oceanographic and meteorological data in tidy format. Package: wior Title: Easy Tidy and Process Oceanographic Data Version: 0.0.0.1 Date: 2020-10-28 Authors@R: c(person(given = &quot;Masumbuko&quot;, family = &quot;Semba&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;), email = &quot;first.lugosemba@gmail.com&quot;, comment = c(ORCID = &quot;https://orcid.org/0000-0002-5002-9747&quot;)), person(given = &quot;Nyamisi&quot;, family = &quot;Peter&quot;, role = &quot;aut&quot;, email = &quot;first.nyamisip@gmail.com&quot;, comment = c(ORCID = &quot;https://orcid.org/0000-0002-4376-2588&quot;))) Description: *wior* is a package intended to transform and process large, complex and diverse oceanographic data acquired through satellite or instrument and turn them into a tibble, an easy way to handle and process data format in R. License: MIT + file LICENSE Encoding: UTF-8 LazyData: true Roxygen: list(markdown = TRUE) RoxygenNote: 7.1.1 Imports: broom,dplyr,magrittr,oce,ggplot2,metR,tidyverse,htmltools,htmltools,sf,btb,tibble,patchwork,rerddap,lubridate,stats,tidyr,raster,cowplot,stars,cubelyr,worldmet,stringr Suggests: knitr,rmarkdown VignetteBuilder: knitr Depends: R (&gt;= 2.10) URL: https://github.com/lugoga/wior 1.1.2 NAMESPACE File The NAMESPACE file specifies the interface to the package that is presented to the user. This is done via a series of export() statements, which indicate which functions in the package are exported to the user. Functions that are not exported cannot be called directly by the user (although see below). In addition to exports, the NAMESPACE file also specifies what functions or packages are imported by the package. If your package depends on functions from another package, you must import them via the NAMESPACE file. Below is the NAMESPACE file for the wior package (Semba and Peter 2020). # Generated by roxygen2: do not edit by hand export(&quot;%&gt;%&quot;) export(add_label) export(binning_points) export(cnv_tibble) export(compute_corr) export(degree2fahrenheit) export(fahrenheit2degree) export(first_cap) export(get_1daysla) export(get_chlModis) export(get_chlSeawif) export(get_meteo) export(get_mld) export(get_oscar) export(get_ppMODIS) export(get_rainLand) export(get_sss) export(get_sstMODIS) export(get_sstMUR) export(get_windAscat) export(get_windQuikscat) export(interp_2d) export(inverse_hyperbolic) export(measure_location) export(measure_summary) export(measure_symetry) export(measure_variation) export(monsoon_season) export(outlier_remove) export(plot_profile) export(point_tb) export(polygon_tb) export(raster_tb) export(sf_crop) export(sf_tibble) export(tibble_sf) export(transect) importFrom(magrittr,&quot;%&gt;%&quot;) Here we can see that all functions are exported from the wior package. We also note that only a single function is importedfrom other packages. importFrom() function takes a package and a series of function names as arguments. This directive allows you to specify exactly which function you need from an external package. For example, this package imports the pipe operator %&gt;% function from the magrittr package (Bache and Wickham 2014). With respect to exporting functions, it is important to think through carefully which functions you want to export. First and foremost, exported functions must be documented and supported. Users will generally expect exported functions to be there in subsequent iterations of the package. Its usually best to limit the number of functions that you export (if possible). Its always possible to export something later if it is needed, but removing an exported function once people have gotten used to having it available can result in upset users. Finally, exporting a long list of functions has the effect of cluttering a users namespace with function names that may conflict with functions from other packages. Minimizing the number of exports reduces the chances of a conflict with other packages (using more package-specific function names is another way). 1.1.3 Namespace Function Notation As you start to use many packages in R, the likelihood of two functions having the same name increases. For example, the commonly used dplyr package has a function named filter(), which is also the name of a function in the stats package. If one has both packages loaded (a more than likely scenario) how can one specific exactly which filter() function they want to call? In R, every function has a full name, which includes the package namespace as part of the name. This format is along the lines of :: For example, the filter() function from the dplyr package can be referenced as dplyr::filter(). This way, there is no confusion over which filter() function we are calling. While in principle every function can be referenced in this way, it can be tiresome for interactive work. However, for programming, it is often safer to reference a function using the full name if there is even a chance that there might be confusion. 1.1.4 Loading and Attaching a Package Namespace When dealing with R packages, its useful to understand the distinction between loading a package namespace and attaching it. When package A imports the namespace of package B, package A loads the namespace of package B in order to gain access to the exported functions of package B. However, when the namespace of package B is loaded, it is only available to package A; it is not placed on the search list and is not visible to the user or to other packages. Attaching a package namespace places that namespace on the search list, making it visible to the user and to other packages. Sometimes this is needed because certain functions need to be made visible to the user and not just to a given package. 1.1.5 The R Sub-directory The R sub-directory contains all of your R code, either in a single file, or in multiple files. For larger packages its usually best to split code up into multiple files that logically group functions together. The names of the R code files do not matter, but generally its not a good idea to have spaces in the file names. 1.1.6 The man Sub-directory The man sub-directory contains the documentation files for all of the exported objects of a package. With older versions of R one had to write the documentation of R objects directly into the man directory using a LaTeX-style notation. However, with the development of the roxygen2 package, we no longer need to do that and can write the documentation directly into the R code files. Therefore, you will likely have little interaction with the man directory as all of the files in there will be auto-generated by the roxygen2 package. 1.1.7 Summary R packages provide a convenient and standardized mechanism for distributing R code to a wide audience. As part of building an R package you design an interface to a collection of functions that users can access to make use of the functionality you provide. R packages are directories containing R code, documentation files, package metadata, and export/import information. Exported functions are functions that are accessible by the user; imported functions are functions in other packages that are used by your package. References "],["r-package.html", "Chapter 2 R package 2.1 Package Development", " Chapter 2 R package When you need to develop a package, you need some tools for that task. Since I am going to illustrate to develop R package inside Rstudio, you ought to know some basic tools required to accomplish the task. Table 2.1 shows the package you need to install them to be able to work smoothly on package development. The version of the software or package is also shown in table 2.1 for you to check the version you have in your machine and whether you need to update them. ## Loading required package: magrittr Table 2.1: Software and Packages Software/Package Version R 4.0.3 Rstudio 1.4 devtools 2.3.2 usethis 1.6.3 tidyverse 1.3.0 rlang 0.4.8 broom 0.7.1 R package development has become substantially easier in recent years with the introduction of a packages like devtools (Wickham, Hester, and Chang 2020) and usethis (Wickham and Bryan 2020). These packages includes a variety of functions that facilitate software development in R. During package development stages, you will find that some functions you use once (single use) and others are used several times (multiple usage). Table 2.2 highlights some functions and whether are single used and multiple uses during package development Table 2.2: Single and multiple usage of functions Function usage Purpose usethis::create_package() Single Initialize package usethis::use_mit_license() Single Add license to package usethis::use_pipe() Single Add pipe function as dependency devtools::check() Multiple build package locally and check devtools::load_all() Multiple load functions into memory usethis::use_r() Multiple create R script for function usethis::use_package() Multiple add package dependency devtools::document() Multiple build and add documentation 2.1 Package Development We begin our package development using the function usethis::create_package(), which basically initialize the package development. usethis::create_package(path = &quot;c:/Users/Semba/Desktop/babye&quot;) This function create an R project with an environment for package development in a location you specified. For this case I have created a package named babye on my desktop. The step-by-step of the process is shown in figure 2.1 Figure 2.1: package development Now that we have a package. lets check it. The function devtools::check was developed for this task as it updates the package documentation, build the package and submit over 50 checks for metadata, structure, R code, documentation and more. This can take a while to run, depending on how big your package is. It is helpful to run frequently, especially if you are planning on submitting to CRAN. But even for internal packages, it is still good practice. A screenshot of our first check is shown in figure 2.2 and spotted a single warning that our package needs a license in the DESCRIPTION file Figure 2.2: Check the package functions We can fix this error by simply add a license on the package project folder. A standard recommendation is the MIT license because of its widely usage and permissions. usethis::use_mit_license(name = &quot;Masumbuko Semba&quot;) Once we run the usethis::use_mit_license(name = \"Masumbuko Semba\") in the command line, it updates the description file and creates two new license files in the project folder (see figure 2.3). It is recommended that the two licenses files never edited. Figure 2.3: Package license Though the tools have added key parts of the DESCTIPTION file, you need to open it and complete the remaining parts and updates the fields with descriptive information. Once you have done that you can re-submit with devtools::check() Figure 2.4: Package free of error We notice that our package is error-free References "],["functions.html", "Chapter 3 Functions 3.1 Document 3.2 Dependencies 3.3 Special Case", " Chapter 3 Functions As mentioned in previous chapter, R packages bundles functions so that are ready and easy available for users. That tells us that the core ingredients of R packages are functions. R packages contains several functions that together make a packages that is aimed to facilitate data import, manipulation and plotting within R environment (R Core Team 2020). Therefore, in this chapter we are going to learn how to make a simple function that work. We are not going to load with you with creating many functions, but we understand that once you master the basic of creating your own function, it will be easy to make more function that are intended to solve a particular data science probem. We create a function and assign it a name max_min. This function aim to find the difference of numeric values in a vector. max_min &lt;- function(x){ max(x) - min(x) } Lets check whether the function work using the famous iris dataset. We only check the difference of variable Sepal.Length max_min(x = iris$Sepal.Length) ## [1] 3.6 That work, what if we use a Species variable max_min(x = iris$Species) We get an error, but the message isnt descriptive. That is common. For us to make descriptive notification when a wrong type of data is provided, we need to add the if-stop function to validity the arguments that are required in the function. We recreate the function and additional arguments to check the validity of the arguments. max_min &lt;- function(x){ if(!is.numeric(x)){ stop(&quot;i am sorry, I can work with a &quot;, class(x)[1], &quot; variable you provided, Please supply me with numeric vector variable&quot;) } max(x) - min(x) } Lets check again the variables species in our functions. max_min(x = iris$Species) Woolah! now we get a descriptive error notification, what if we supply the numeric variable to the function! max_min(iris$Sepal.Width) ## [1] 2.4 Let us add our first function max_min to babye package using usethis::use_r(\"max_min\"). This creates a black R script namedmax_min.Rlocated in theR/` sub-folder in our package directory. It is recommended that the R script and the function bear the same name. Then fill the R script of R function we created with the argument as shown in figure 3.1. Figure 3.1: Function script Once you have created the function, take your function for a test drive with devtools::load_all (arguably the most important part of the devtools workflow). devtools::load_all() places your function in local memory so that you may tinker and confirm its execution. Lets give it a try. 3.1 Document Next document the max_min function using the Roxygen skeleton. The roxygen2 package provides an in-source documentation system that automatically generates R documentation (Rd) files. First, place your cursor in the function definition, and then you can add the skeleton from code &gt; insert Roxygen skeleton in the Rstudio main tab (see figure 3.2). knitr::include_graphics(&quot;img/roxygen_skeleton.png&quot;) Figure 3.2: Inserting function documentation in Rstuido You will get skeleton of documentation for the function, you can fill the field and updates it as you wish. This document the function and briefly describe it, which make it easy for you and user later that help instruct how to use the function. I have updated the max_min function as seen in figure 3.3 Figure 3.3: documented function Once you have update the function document, save it and submit using the devtools::document function. 3.2 Dependencies Its the job of the DESCRIPTION to list the packages that your package needs to work. To specify a package dependency, the name of the package needs to be listed in the DESCRIPTION file. This can be automatically done for you by submitting. Figure 3.4: Package dependency We notice that our package to work with pipe operator, it requires a magritrr package (???). That means when you install this package, it will also install the packages it depends like magritrr. Figure 3.5: Package dependency 3.3 Special Case Although we have imported a magritrr package, this package has special operator called pipe or then denoted as %&gt;%, which provide a convenient way to chain the processes in R. We can add this special function in two steps usethis::use_pipe()which creates utils-pipe.R folder and adds magritrr to imports in the DESCRIPTION file. devtools::document()add the pipe in our package NAMESPACE file. References "],["installing-the-package.html", "Chapter 4 Installing the package", " Chapter 4 Installing the package Once you have finished devloping the package, you can run devtools::document() to submit the package and then devtools::check() to assess of any error in the package. Once the signs are green, you have an error free package and you ready to install it in your machine or share with other colleagues to install into their machine. However, you need to bundle the folder you have been working to develop the package. devtools has a a function build() which was designed specifically for that purpose. build() function converts a package source directory into a single bundled file. If binary = FALSE this creates a tar.gz package that can be installed on any platform, provided they have a full development environment (although packages without source code can typically be installed out of the box). If binary = TRUE, the package will have a platform specific extension (e.g. .zip for windows), and will only be installable on the current platform, but no development environment is needed. devtools::build() Once the zipped file for the package is created, you can install from your local directory using install() function from devtools package. devtools::install(&quot;c:/Users/Semba/Desktop/babye/&quot;) If you have pushed the package into Github, you can still install from it using the code in the chunk below devtools::install_github(&quot;lugoga/babye&quot;) The package will install in your machine and make its functions avaialble for your use. However, to make use of its function you must load the package into your R session using either library() or require() functions. require(babye) "],["final.html", "Chapter 5 Final", " Chapter 5 Final R packages provide a convenient and standardized mechanism for distributing R code to a wide audience. As part of building an R package you design an interface to a collection of functions that users can access to make use of the functionality you provide. R packages are directories containing R code, documentation files, package metadata, and export/import information. Exported functions are functions that are accessible by the user; imported functions are functions in other packages that are used by your package. We just scratch the surface on how one can start developing R packages. I hope you feel empowered to start developing your own packages now! We went through many of these steps one time only; however, in the development process, some of these steps are iterative. Table 5.1 highlight key steps we went together and it can be used as reference material when you get entangled along the stage, then table 5.1 can resourceful. Table 5.1: Key functions in sequantial order during package developmnent SN Step tools 1 Load development packages library(usethis), library(devtools) 2 Create new package usethis::create_package(path/package) 3 Optional: Connect to GitHub repo usethis::use_git(), usethis::use_github() 4 Check build devtools::check() 5 Add license usethis::use_mit_license(Your name) 6 Check build devtools::check() 7 Create new function usethis::use_r(function) 8 Test drive function devtools::load_all() 9 Insert Roxygen skeleton Menu -&gt; Code -&gt; Insert Roxygen Skeleton 10 Document package devtools::document() 11 Check build devtools::check() 12 Specify package dependencies usethis::use_package(package) 13 Specify functions within packages package::function 14 Document package devtools::document() 15 Check build devtools::check() 16 Install package devtools::install(path/package), or NA NA devtools::install_github(user/repo) "],["references.html", "References", " References Bache, Stefan Milton, and Hadley Wickham. 2014. Magrittr: A Forward-Pipe Operator for R. https://CRAN.R-project.org/package=magrittr. R Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Semba, Masumbuko, and Nyamisi Peter. 2020. Wior: Easy Tidy and Process Oceanographic Data. Wickham, Hadley, and Jennifer Bryan. 2020. Usethis: Automate Package and Project Setup. https://CRAN.R-project.org/package=usethis. Wickham, Hadley, Jim Hester, and Winston Chang. 2020. Devtools: Tools to Make Developing R Packages Easier. https://CRAN.R-project.org/package=devtools. Xie, Yihui. 2020. Bookdown: Authoring Books and Technical Documents with R Markdown. https://github.com/rstudio/bookdown. "]]
